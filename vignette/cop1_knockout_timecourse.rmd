---
title: "Cop1 role in pro-inflammatory response - a time-course data analysis."
author: 
  - name: Lan Huong Nguyen
    affiliation: Institute for Computational and Mathematical Engineering, Stanford University, CA 94305
keywords: time-course, time series, PCA, clustering, differential expression.
date: "`r BiocStyle::doc_date()`"
output: 
  BiocStyle::html_document2:
    toc_float: true
    df_print: paged
vignette: >
  %\VignetteIndexEntry{Gene expression time course data analysis}
  %\VignetteEngine{knitr::rmarkdown}
---


```{r style, echo=FALSE, message=FALSE, warning=FALSE, results="asis"}
rm(list = ls())
library("BiocStyle")
library("knitr")
library("rmarkdown")
options(width = 200) 
opts_chunk$set(
  message = FALSE, error = FALSE,
  warning = FALSE, fig.width = 10, fig.height = 7,
  fig.path = "figs/", dev='png') 
```


Abstract {#abstract .unnumbered}
================================

The analysis of time course data is non-trivial
as in involves dependencies between data points.
Our package helps researchers analyze RNA-seq
datasets which include gene expression measurements
taken over time. The methods are specifically
designed for at datasets with a small number of 
available replicates and time points is small,
which is a typical case for RNA-seq time course
studies. Short time courses are more difficult 
to analyze, as many statistical methods designed for 
time series data might require a minimum number 
of time points, e.g. functional data analysis (FDA) 
and goodness of fit methods might be ineffective. 
Our approach are non-parametric and distance-based
which gives the user a flexibility to incorporate
different normalization techniques, and distance metrics. 
`funtimeseq` is a comprehensive time course 
analysis toolbox with methods for data visualization,
clustering and differential expression analysis.
Additionally, the package can perform enrichment 
analysis for DE genes.


Introduction {#introduction .unnumbered}
========================================

We will demonstrate the effectiveness of `vistimeseq` package using the in-house 
dataset exploring the role of Cop1 in pro-inflammatory response. The experiments 
were designed to study the induction and repression kinetics of genes in bone 
marrow derived macrophages (BMDMs).

The dataset includes cells from 6 mice. The cells were divided into two equal 
groups. For one group the Cop1 gene was in vitro knock out with tamoxifen. 
All samples where then subject to LPS treatment to induce an inflamatory 
response. Bulk RNA-seq was performed at 6 time-points: one at time 0 before 
LPS treatment, then at time 2.5, 4, 6, 9 and 13 hours after LPS was added. 



Obtain and process data {#get-data .unnumbered}
===============================================


First we load the necessary packages.

```{r message=FALSE, warning=FALSE}
.packages <- c("dplyr", "edgeR", "ggplot2", "tibble", "tidyr", 
               "viridis", "vistimeseq", "Biobase") 
sapply(.packages, require, character.only = TRUE)
theme_set(theme_bw())
theme_update(text = element_text(size = 15))
```

The dataset from the study is shipped together with the package as an 
`ExressionSet` object. We can read the data as follows:

```{r, message=FALSE, warning=FALSE}
# Load gene data
cop1_eset <- readRDS(
  file = system.file("extdata", "NGS1471_esetCounts.rds", 
                     package = "vistimeseq", mustWork = TRUE)
)
```

Then, we can access individual fields of `cop1_eset` using functions from
`Biobase` packages. First, we extract the gene phenotype data.

```{r}
# Gene data
gene_data <- fData(cop1_eset) 
gene_data[["feature"]] <- rownames(gene_data)
gene_data <- gene_data %>%
  select(feature, symbol, size, type, desc)
head(gene_data)
```

Then, we read and process the sample data. The information we need about 
each sample is (1) the experimental group it belongs to -- here whether a sample
corresponds to a wild type mouse or one with Cop1 knocked out, (2) the replicate
id -- as multiple samples where collected for the same conditions, (3) and
most importantly time -- the point in the course of the study at which a sample 
was collected.

```{r}
# Sample data
smp_data <- pData(cop1_eset) %>%
  rename(sample = SAMPLE_ID) %>%
  mutate(
    tmp = factor(time, levels = c("T0", "T2.5", "T4", "T6", "T9", "T13")),
    time = as.numeric(gsub("T", "", time)),    
    replicate = paste0(genotype, "_", individual),
    label = paste0(genotype, "_", individual, "_", time),
    group = genotype
  ) %>%
  arrange(group, individual, time) %>%
  select(sample, group, individual, replicate, time, treatment, label)
rownames(smp_data) <- smp_data$sample
head(smp_data)
```

Finally, we also extract the expression data -- the raw gene read counts.

```{r}
cnts <- exprs(cop1_eset)[, smp_data$sample]        # count data
dim(cnts)
```


Building `vistimeseq` object {#build-object .unnumbered}
========================================================

We can now combine all the data, `cnts`, `gene_data` and `smp_data`, into
a single `vistimeseq` (S4) object. The data will store everything together
in a way that is easier to perform further time course data analysis.
The most important fields in the object are "raw.data", "sample.data"
which will contain information on group, replicate and time associated
with each sample. As everything we need is stored in the "vistimeseq"
object generated, we can discard all the data we generated previously.

```{r}
cop1_timeseq <- vistimeseq(
  project = "[NGS1474] Time course in vitro Cop1 KO in BMDMs",
  raw.data = cnts,
  feature.data = gene_data,
  sample.data = smp_data,
  time_column = "time",
  replicate_column = "replicate",
  group_column = "group"
) 
rm(cnts, gene_data, smp_data, cop1_eset)
cop1_timeseq
```

Data normalization and filtering {#norm-and-filter .unnumbered}
---------------------------------------------------------------

The raw read counts cannot be immediately used for analysis, as 
sequencing data involves the issue of varying sample depths.
We can convert the raw counts to counts per million (CPM) 
using `vistimeseq` function, `normalize_data()`, which performs
data normalization by column. Currently, we only support scaling 
sample counts by constant factors (size factors). If the argumennt
`column.scale.factor` is not specified, by default `vistimeseq` divides by 
column sums and multiplies by 1 million to obtain CPMs. The normalized
data is stored separately from the raw data in a slot "data".

```{r}
# Compute CPMs and store in cop1_timeseq@data 
cop1_timeseq <- normalize_data(cop1_timeseq) 
```


Since the dataset contains more than 36k genes, we will filter out the very 
rare ones which we assume to be too noisy and not containing enough signal
for further analysis.

Here, we find and remove all genes which have the mean expression (CPM) below 
`min_mean_cpm` = 5 within either of the two groups of interest,
*wild type* or *knock-out*.

```{r}
# Fine genes with minimum mean count of 5 at least in one of the two groups
min_mean_cpm <- 5
group_cpm_means <- data.frame(row.names = cop1_timeseq@feature.names)
for(g in unique(cop1_timeseq@group )) {
  g_cnts <- cop1_timeseq@data[ , which(cop1_timeseq@group == g)]
  group_cpm_means[, g] <- apply(g_cnts, 1, mean)
}
group_cpm_max <- apply(as.vector(group_cpm_means), 1, max)
genes_expressed <- cop1_timeseq@feature.names[group_cpm_max > min_mean_cpm]
```

```{r}
# Filter out the noisy genes
cop1_timeseq <- filter_features(cop1_timeseq, genes_expressed) 
cop1_timeseq
```

Collapse replicates {#collapse-replicates .unnumbered}
------------------------------------------------------

In parts of our later analysis, we will make comparisons between genes, 
and therefore it is useful to aggregate gene expression accross replicates
to obtain their mean behaviour. To do this we can use `collapse_replicates()`
function for `vistimeseq`. The function saves collapsed sample
and aggregated expression data in "sample.data.collapsed", and "data.collapsed"
respectively. 

```{r}
# Collapsed sample data stored in cop1_timeseq@sample.data.collapsed, 
# and mean expression values in cop1_timeseq@data.collapsed
cop1_timeseq <- collapse_replicates(cop1_timeseq, FUN = mean)
```


Time course format {#timecourse-format .unnumbered}
===================================================

The main focus on `vistimeseq` is to analyze and visualize time-series
data efficiently. For this reason, we convert the expression data in
a form of a rectancular matrix into a "time-course format" where
each row stores a single time series corresponding to a specified
combination of group membership and and replicate id (here mouse id). 
This data wranggling step can be performed with `convert_to_timecourse()`
function, the "time-course" will be stored in a slot `timecourse.data`.
This slot contains a list containing data.frames `tc` and `tc_collapsed`
(if `data.collapsed` is defined).

Before converting data to "time-course" format, gene transformation 
should be performed. This step is recommended because RNA-seq data is highly 
heteroscedastic, which means the features (genes) included have vastly 
different variances. It is know that bulk expression count data can be well 
odelled with a negative binomial distribution. In this distribution, variance 
is a quadratic function of the mean, $\sigma^2 = \mu + \alpha\mu^2$. That is 
the higher the mean expression level, the higher the variance is. 

Data transformation is thus necessary for a fair gene-to-gene comparison.
For example, when clustering genes, one uses pairwise distances to estimate 
dissimilarities between genes. Since, we are generally more interested in 
grouping genes based on similarities in their trajectories rather than their 
absolute expression levels, the read counts must be transformed before computing
the distances. 

Currently, gene transformation methods available in `vistimeseq` are 
"scale_feat_sum" (scaling by gene sum) or "var_stab" (variance stabilization). 
The user can specifiy a variance stabilization method if "var_stab"
is used. VST methods supported are: "log1p" (log plus one), "asinh" 
(inverse hyperbolic sine) or "deseq" 
(`DESeq2::varianceStabilizingTransformation`).

```{r}
# Before conversion, scales gene expression to an even sum, for a fair 
# gene-to-gene comparison.
cop1_timeseq <- convert_to_timecourse(
  cop1_timeseq, feature.trans.method = "scale_feat_sum")
```

Lag differences {#lags .unnumbered}
-----------------------------------

Time-series data have a dependency structure and are not standard multivariate 
vectors. Many methods have been developed for representing time-series data. 
A common technique is for example to fit functions e.g. polynomials 
or splines to the data. A similar approach is taken in functional data analysis 
(FDA) literature, where time series  are represented as linear combinations 
of basis functions (e.g. principal functions). These methods seek to smooth
the data and to reduce of complexity of the inherent (infinite dimensional) 
functional data. The fitted coefficients are often used as the time-series
representatiom then used for clustering or visualization. 

Unfortunately, most of the biological time course studies are short, sometimes
containing as few as three or four time-points. Therefore, fitting functions 
to sparse time points would be inefficient. Instead, here we propose a simpler
way to incorporate the dependecy structure of the time-series. Our
method involves construction of additional data features, which are lag 
differences between consecutive time-points. Lag of order 1 for time-point 
$i$, $Lag_1(i)$, denotes the difference between the expression level at time 
$i$ and time $i-1$, lag 2 is the difference between time $i$ and time $i-2$, 
and so on. Intuitively, the lag 1 at time $i$ approximates the slope or the 
first derivative of the time series curve at time-point $i$.

We can add these extra lag features to the "time-course" data using 
`add_lags()` function, whcih appends lag features to "tc" and "tc_collapsed"
data frames in the slot `timecourse.data`. Additionally,the user can define
the weight for each lag feature by specifying the `lambda` argument.
The length of `lambda` indicates how many orders of lags one would like
to include, e.g. `lambda = c(0.5, 0.25)` means lag order 1 will be
added with multiplicative weight of $0.5$ and lag order 2 will be added with
weight $0.025$.
 

```{r}
# Add lags to time-course data
cop1_timeseq <- add_lags(cop1_timeseq, lambda = c(0.5, 0.25))
head(cop1_timeseq@timecourse.data$tc)
```

At this point, we completed all data pre-processing steps available in 
`vistimeseq`. In later sections we specify how visualization, clustering
and differential expression test can be performed with the package.


Data Visualization {#datavis .unnumbered}
=========================================

In this section we show plotting utilities available in `vistimeseq`.
Visualizations are data exploration tools and serve as the first step in our
data analysis. In the following subsections we will describe more in details
how heatmaps and PCA plots can be generated.

Heatmaps {#heatmap .unnumbered}
------------------------------

Here we will generate a heatmap of top 200 most variable genes.
The plot of the expression matrix for these most variable features will
give us some insight whether there is  a clear difference between the
two exprerimental groups and whether a strong temporal trend can be detected.

```{r, fig.height=9, fig.width=7}
plot_heatmap(cop1_timeseq)
```

In the above heatmap the colums are ordered by experimental group, replicate 
(mouse id) and time at which the sample was sequenced; the sample membership
is indicated in the color bars on top of the columns. The main heatmap
rectangle shows Z-scores of expression values represented by colors in
the red-and-blue palette corresponding to high-and-low respectively. Even this
first look at the data, shows us patterns present in the data -- within each 
condition, i.e. each mouse and in each experimental group there are expression
levels seem to be dependent on time. 


PCA {#pca .unnumbered}
======================

Another way to explore the dataset is through dimensionality reduction.
Here we will project the data into a space of principal componets.
With PCA, one can visualize both samples and features in the same coordinates 
space with a biplot. Here we will keep these two maps separately,
as the visualization can become overcrowded with points which obscure
the inherent structure. Eventhough, we are plotting the feature and sample
projections separately, they can be compared side by side to see
which groups of features are more correlated with which group of samples.


Visualizing Samples {#sample-vis .unnumbered}
---------------------------------------------

First, we project samples on a 2D map to check whether their relative location
reflects time at which the sequencing was performed. If the samples are ordered 
in agreement with time in the PCA plot, there might be patterns in gene 
expression levels changing over the course of the study.

A PCA plot can also be used to examine whether samples corresponding to the 
same condition, here wilde type or knockouts, tend to group together, i.e.
whether they are more similar to each other than to the ones in a different
condition. We use `prcomp()` function from `stats` (default) package to compute 
PCA projection.

PCA projection maximizes the amount variance preserved in consecutive principal 
components. This implies that computing PCA on raw expression counts 
or even the CPMs would put too much weight on highly abundant genes. 
Thus, we recommend user to variance stabilize the data before computing 
a PCA projection  (as described in *Time course format* section). 
The variance stabilization method can be specified in `var.stabilize.method`
argument.

Additionally, the user might limit calculations to only specific group of 
samples, e.g. in this case one might be interested in visualizing samples
only in the wild type group. A user can also indicate whether
PCA should be applied to sample resolved data or one with replicates aggregated  
(stored in "data.collapsed" slot of a `vistimseq` object).

```{r}
cop1_timeseq <- run_pca(cop1_timeseq, var.stabilize.method = "asinh") 
```

```{r pca-samples-group, fig.wide = TRUE, fig.height=3, fig.width=7}
plot_sample_pca(cop1_timeseq, col.var = "group", size = 4) 
```

```{r pca-samples-time, fig.wide = TRUE, fig.height=3, fig.width=7}
plot_sample_pca(cop1_timeseq, col.var = "time", size = 4) 
```

In the plots above we see that the samples group mostly by time at which
they have benn sequences. For some time-points, we see also a clear separation
between sample from different experimental groups.

Visualizing Features {#feat-vis .unnumbered}
-------------------------------------------------

PCA also provides a projection of features to the same principal component
space. The coordinates of features (here genes) are commonly referred to
as PCA loadings. Since gene expression datasets usually includes thousands
of genes, it is not possible to include labels for all of them in
the same 2D PCA plot. Apart from that, in a time-course study one is
interested in trajectories of genes over time, and it is good to see groups
of genes with similar expression pattern clustered together on a visualization.

In order to make PCA plots for features more informative, we overlay 
average (over replicates) gene expression trend over time for each experimental 
group. Plotting trajectories for every gene would make plot overcrowded and
unreadable, therefore we divide the PCA plot into $m \times n$ grid and plot
a trajectory for a gene whoch PCA coordinates are closes to the grid center 
point.

In the feature PCA plot below we see that genes exhibit different responses to 
LPS treatment. The figure shows genes organized according to their trajectory.
Inhibited genes tend to gather on the left side of the plot, the primary
response (early spike) genes are in the bottom, and the late response 
(late increase) clustered on the top-right corner. The plot doesn't show a 
global difference between the wild type and knock-out group. Most genes 
have trajectories that are exactly overlapping in both conditions.



```{r pca-genes-human, fig.width = 9, fig.height = 7}
plot_ts_pca(
  cop1_timeseq, 
  linecol = c("WT" = "#e31a1c", "Loxp" = "#1f78b4"),
  main = paste("Visualizing gene profiles with PCA"), 
  col = adjustcolor("grey77", alpha=0.7))
```



Gene Clustering {#clustering .unnumbered}
=========================================

To cluster the gene trajectories we will use the data stored in 
`timecourse.data` slot of `cop1_timeseq`. These are time-series
of transformed expression values together with appended time lags
which relsoving differences between the temporal trends. 

We use hierarchical clustering define gene groupings. 
Either static or dynamic branch cutting (from `dynamicTreeCut` package)
algorithms can be used to assign clusters. Since hierarchical clustering 
is computationally intensive (with $O(n^3)$ complexity for standard 
implementations), we apply it only to a subset of genes. 
Specifically, we pick `n_top_genes` with average (over replicates) most 
variable expression over time in each of selected \code{groups} (here
we use both wild type and knock-out) to perform clustering. Remaining genes are, 
then, assigned to a cluster with the closest centroid. An additional advantage
of using only a subset of most variable genes for clustering is that, the core 
genes which exhibit negligible changes over time (which might be the majority 
of genes) will not much effect on clustering results.


```{r}
params_for_clustering <- list(
  dynamic = TRUE, 
  dynamic_cut_params = list(deepSplit = TRUE, minModuleSize = 150))
  
cop1_timeseq <- cluster_timecourse_features(
  cop1_timeseq, n_top_feat = 3000, groups = "all",
  clust_params = params_for_clustering)

```

We can see the size of each of clusters computed

```{r}
# See the count of genes in each cluster
cluster_map <- cop1_timeseq@cluster.features$cluster_map
table(cluster_map$cluster)
```

We can plot the hclust dendrogram obtained from hierarchical clustering 
performed.

```{r hclust-dendrogram}
# Plot the hierarchical clustering of genes2cluster
hclust_obj <- cop1_timeseq@cluster.features$hclust
plot(x = hclust_obj, labels = FALSE, 
     xlab = "genes", sub = "")
```

Here we plot average (over replicates) gene trajectories grouped into six
clusters found using the above described approach. The expression profiles
for wild type and knock-out are plotted separately, side by side.
for  and show the corresponding KO
gene profiles for comparison:

```{r gene-clusters, fig.width = 10, fig.height = 8, fig.wide = TRUE}
plot_ts_clusters(cop1_timeseq, alpha = 0.2) +
  scale_color_manual(values = c("WT" = "#1f78b4", "Loxp" = "#e31a1c"))
```





Differential Expression Ranking {#diff-expr .unnumbered}
========================================================





Functional pathways discovery {#fun-path .unnumbered}
=====================================================





Session Information {#session-info .unnumbered}
===============================================

```{r}
sessionInfo()
```


